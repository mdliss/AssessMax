"""
Lambda function to persist scoring results from S3 to PostgreSQL database.

For backwards compatibility this handler understands both the legacy
keyword-based payload (scores keyed by student name) and the new LLM payload
generated by the scoring Lambda.
"""

from __future__ import annotations

import json
import logging
import os
import sys
from datetime import date
from typing import Any, Tuple
from uuid import NAMESPACE_DNS, uuid5

import boto3

# Ensure shared modules are importable (packaged in Lambda layer or local env)
sys.path.insert(0, "/opt/python")
LOCAL_APP_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if LOCAL_APP_PATH not in sys.path:
    sys.path.insert(0, LOCAL_APP_PATH)

from lambdas.common.persistence import PersistenceSummary, persist_llm_results  # noqa: E402

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# AWS clients
s3_client = boto3.client("s3")

# Environment variables
DATABASE_URL = os.environ.get("DATABASE_URL")
OUTPUTS_BUCKET = os.environ.get("S3_OUTPUTS_BUCKET")
DEFAULT_MODEL_VERSION = os.environ.get("LLM_MODEL_VERSION", "llm-1.0.0")


def _normalize_students_payload(
    raw_payload: Any,
    class_id: str,
) -> Tuple[dict[str, dict[str, Any]], str]:
    """
    Normalize scoring payload into the canonical student mapping.

    Returns:
        (students_dict, model_version)
    """
    if isinstance(raw_payload, dict) and "students" in raw_payload:
        model_version = raw_payload.get("model_version", DEFAULT_MODEL_VERSION)
        students_data = raw_payload.get("students", {})
        if not isinstance(students_data, dict):
            raise ValueError("Expected 'students' to be a mapping")
        return students_data, model_version

    if not isinstance(raw_payload, dict):
        raise ValueError("Unsupported scoring payload format: expected dict")

    logger.warning("Converting legacy keyword-based scoring payload to LLM format")
    students: dict[str, dict[str, Any]] = {}

    for student_name, student_data in raw_payload.items():
        student_uuid = str(uuid5(NAMESPACE_DNS, f"{class_id}:{student_name}"))
        scores = student_data.get("scores", {})
        evidence = student_data.get("evidence", {})

        converted_scores: dict[str, Any] = {}
        for skill, metrics in scores.items():
            score_raw = metrics.get("score", 0.0)
            # Legacy scores were 0-1; convert to 0-10 scale
            converted_scores[skill] = {
                "score": round(float(score_raw) * 10, 1),
                "confidence": float(metrics.get("confidence", 0.3)),
                "evidence_count": int(metrics.get("demonstration_count", 0)),
            }

        converted_evidence: dict[str, list[dict[str, Any]]] = {}
        for skill, evidence_items in evidence.items():
            converted_evidence[skill] = []
            for item in evidence_items or []:
                quote = item.get("text", "")
                keyword = item.get("keyword")
                rationale = item.get("rationale") or (
                    f"Keyword '{keyword}' indicates {skill}" if keyword else f"Evidence of {skill}"
                )
                converted_evidence[skill].append(
                    {
                        "quote": quote,
                        "rationale": rationale,
                        "score_contribution": 0.5,
                        "confidence": 0.6,
                    }
                )

        students[student_uuid] = {
            "student_id": student_uuid,
            "student_name": student_name,
            "student_external_id": None,
            "scores": converted_scores,
            "evidence": converted_evidence,
            "utterance_count": student_data.get("utterance_count", 0),
            "words_spoken": student_data.get("words_spoken", 0),
        }

    return students, "legacy-keyword"


def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    """
    Lambda handler for persisting scoring results to PostgreSQL.
    """
    if not DATABASE_URL:
        raise RuntimeError("DATABASE_URL environment variable is not set")

    try:
        logger.info("Persistence Lambda invoked with event: %s", json.dumps(event))

        job_id = event.get("job_id")
        class_id = event.get("class_id")
        session_date_str = event.get("date")
        scoring_result = event.get("scoringResult", {})
        output_key = scoring_result.get("output_key")

        if not all([job_id, class_id, session_date_str, output_key]):
            raise ValueError(
                f"Missing required fields: job_id={job_id}, class_id={class_id}, "
                f"date={session_date_str}, output_key={output_key}"
            )

        session_date = date.fromisoformat(session_date_str)

        logger.info("Downloading scoring results from s3://%s/%s", OUTPUTS_BUCKET, output_key)
        response = s3_client.get_object(Bucket=OUTPUTS_BUCKET, Key=output_key)
        raw_payload = json.loads(response["Body"].read().decode("utf-8"))

        students_payload, model_version = _normalize_students_payload(raw_payload, class_id)
        students_count = len(students_payload)
        logger.info(
            "Loaded scoring data for %d students (model_version=%s)",
            students_count,
            model_version,
        )

        summary: PersistenceSummary = persist_llm_results(
            DATABASE_URL,
            class_id,
            session_date,
            model_version,
            students_payload,
        )

        logger.info(
            "Persisted assessments for job %s: %s",
            job_id,
            summary.as_dict(),
        )

        return {
            "statusCode": 200,
            "job_id": job_id,
            "students_processed": summary.students_processed,
            "assessments_created": summary.assessments_created,
            "evidence_created": summary.evidence_created,
            "message": (
                f"Persisted assessments for {summary.students_processed} students "
                f"(model_version={model_version})"
            ),
        }

    except Exception as exc:
        logger.error("Error in persistence Lambda: %s", exc, exc_info=True)
        raise

